// Code generated by mockery v2.52.4. DO NOT EDIT.

package fakestore

import (
	context "context"
	http "net/http"

	fakestore "github.com/radityacandra/ecommerce-connector-cli/internal/application/product/client/fakestore"

	io "io"

	mock "github.com/stretchr/testify/mock"
)

// MockClientInterface is an autogenerated mock type for the ClientInterface type
type MockClientInterface struct {
	mock.Mock
}

type MockClientInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MockClientInterface) EXPECT() *MockClientInterface_Expecter {
	return &MockClientInterface_Expecter{mock: &_m.Mock}
}

// AddCart provides a mock function with given fields: ctx, body, reqEditors
func (_m *MockClientInterface) AddCart(ctx context.Context, body fakestore.Cart, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddCart")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.Cart, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.Cart, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, fakestore.Cart, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_AddCart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCart'
type MockClientInterface_AddCart_Call struct {
	*mock.Call
}

// AddCart is a helper method to define mock.On call
//   - ctx context.Context
//   - body fakestore.Cart
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) AddCart(ctx interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_AddCart_Call {
	return &MockClientInterface_AddCart_Call{Call: _e.mock.On("AddCart",
		append([]interface{}{ctx, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_AddCart_Call) Run(run func(ctx context.Context, body fakestore.Cart, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_AddCart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(fakestore.Cart), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_AddCart_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_AddCart_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_AddCart_Call) RunAndReturn(run func(context.Context, fakestore.Cart, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_AddCart_Call {
	_c.Call.Return(run)
	return _c
}

// AddCartWithBody provides a mock function with given fields: ctx, contentType, body, reqEditors
func (_m *MockClientInterface) AddCartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddCartWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_AddCartWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCartWithBody'
type MockClientInterface_AddCartWithBody_Call struct {
	*mock.Call
}

// AddCartWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) AddCartWithBody(ctx interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_AddCartWithBody_Call {
	return &MockClientInterface_AddCartWithBody_Call{Call: _e.mock.On("AddCartWithBody",
		append([]interface{}{ctx, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_AddCartWithBody_Call) Run(run func(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_AddCartWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_AddCartWithBody_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_AddCartWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_AddCartWithBody_Call) RunAndReturn(run func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_AddCartWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// AddProduct provides a mock function with given fields: ctx, body, reqEditors
func (_m *MockClientInterface) AddProduct(ctx context.Context, body fakestore.Product, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddProduct")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.Product, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.Product, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, fakestore.Product, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_AddProduct_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddProduct'
type MockClientInterface_AddProduct_Call struct {
	*mock.Call
}

// AddProduct is a helper method to define mock.On call
//   - ctx context.Context
//   - body fakestore.Product
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) AddProduct(ctx interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_AddProduct_Call {
	return &MockClientInterface_AddProduct_Call{Call: _e.mock.On("AddProduct",
		append([]interface{}{ctx, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_AddProduct_Call) Run(run func(ctx context.Context, body fakestore.Product, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_AddProduct_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(fakestore.Product), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_AddProduct_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_AddProduct_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_AddProduct_Call) RunAndReturn(run func(context.Context, fakestore.Product, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_AddProduct_Call {
	_c.Call.Return(run)
	return _c
}

// AddProductWithBody provides a mock function with given fields: ctx, contentType, body, reqEditors
func (_m *MockClientInterface) AddProductWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddProductWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_AddProductWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddProductWithBody'
type MockClientInterface_AddProductWithBody_Call struct {
	*mock.Call
}

// AddProductWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) AddProductWithBody(ctx interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_AddProductWithBody_Call {
	return &MockClientInterface_AddProductWithBody_Call{Call: _e.mock.On("AddProductWithBody",
		append([]interface{}{ctx, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_AddProductWithBody_Call) Run(run func(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_AddProductWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_AddProductWithBody_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_AddProductWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_AddProductWithBody_Call) RunAndReturn(run func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_AddProductWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// AddUser provides a mock function with given fields: ctx, body, reqEditors
func (_m *MockClientInterface) AddUser(ctx context.Context, body fakestore.User, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddUser")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.User, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.User, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, fakestore.User, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_AddUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddUser'
type MockClientInterface_AddUser_Call struct {
	*mock.Call
}

// AddUser is a helper method to define mock.On call
//   - ctx context.Context
//   - body fakestore.User
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) AddUser(ctx interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_AddUser_Call {
	return &MockClientInterface_AddUser_Call{Call: _e.mock.On("AddUser",
		append([]interface{}{ctx, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_AddUser_Call) Run(run func(ctx context.Context, body fakestore.User, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_AddUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(fakestore.User), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_AddUser_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_AddUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_AddUser_Call) RunAndReturn(run func(context.Context, fakestore.User, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_AddUser_Call {
	_c.Call.Return(run)
	return _c
}

// AddUserWithBody provides a mock function with given fields: ctx, contentType, body, reqEditors
func (_m *MockClientInterface) AddUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddUserWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_AddUserWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddUserWithBody'
type MockClientInterface_AddUserWithBody_Call struct {
	*mock.Call
}

// AddUserWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) AddUserWithBody(ctx interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_AddUserWithBody_Call {
	return &MockClientInterface_AddUserWithBody_Call{Call: _e.mock.On("AddUserWithBody",
		append([]interface{}{ctx, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_AddUserWithBody_Call) Run(run func(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_AddUserWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_AddUserWithBody_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_AddUserWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_AddUserWithBody_Call) RunAndReturn(run func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_AddUserWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCart provides a mock function with given fields: ctx, id, reqEditors
func (_m *MockClientInterface) DeleteCart(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCart")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, id, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, id, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_DeleteCart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCart'
type MockClientInterface_DeleteCart_Call struct {
	*mock.Call
}

// DeleteCart is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) DeleteCart(ctx interface{}, id interface{}, reqEditors ...interface{}) *MockClientInterface_DeleteCart_Call {
	return &MockClientInterface_DeleteCart_Call{Call: _e.mock.On("DeleteCart",
		append([]interface{}{ctx, id}, reqEditors...)...)}
}

func (_c *MockClientInterface_DeleteCart_Call) Run(run func(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_DeleteCart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_DeleteCart_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_DeleteCart_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_DeleteCart_Call) RunAndReturn(run func(context.Context, int, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_DeleteCart_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProduct provides a mock function with given fields: ctx, id, reqEditors
func (_m *MockClientInterface) DeleteProduct(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProduct")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, id, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, id, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_DeleteProduct_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProduct'
type MockClientInterface_DeleteProduct_Call struct {
	*mock.Call
}

// DeleteProduct is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) DeleteProduct(ctx interface{}, id interface{}, reqEditors ...interface{}) *MockClientInterface_DeleteProduct_Call {
	return &MockClientInterface_DeleteProduct_Call{Call: _e.mock.On("DeleteProduct",
		append([]interface{}{ctx, id}, reqEditors...)...)}
}

func (_c *MockClientInterface_DeleteProduct_Call) Run(run func(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_DeleteProduct_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_DeleteProduct_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_DeleteProduct_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_DeleteProduct_Call) RunAndReturn(run func(context.Context, int, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_DeleteProduct_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUser provides a mock function with given fields: ctx, id, reqEditors
func (_m *MockClientInterface) DeleteUser(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUser")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, id, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, id, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_DeleteUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUser'
type MockClientInterface_DeleteUser_Call struct {
	*mock.Call
}

// DeleteUser is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) DeleteUser(ctx interface{}, id interface{}, reqEditors ...interface{}) *MockClientInterface_DeleteUser_Call {
	return &MockClientInterface_DeleteUser_Call{Call: _e.mock.On("DeleteUser",
		append([]interface{}{ctx, id}, reqEditors...)...)}
}

func (_c *MockClientInterface_DeleteUser_Call) Run(run func(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_DeleteUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_DeleteUser_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_DeleteUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_DeleteUser_Call) RunAndReturn(run func(context.Context, int, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_DeleteUser_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllCarts provides a mock function with given fields: ctx, reqEditors
func (_m *MockClientInterface) GetAllCarts(ctx context.Context, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAllCarts")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_GetAllCarts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllCarts'
type MockClientInterface_GetAllCarts_Call struct {
	*mock.Call
}

// GetAllCarts is a helper method to define mock.On call
//   - ctx context.Context
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) GetAllCarts(ctx interface{}, reqEditors ...interface{}) *MockClientInterface_GetAllCarts_Call {
	return &MockClientInterface_GetAllCarts_Call{Call: _e.mock.On("GetAllCarts",
		append([]interface{}{ctx}, reqEditors...)...)}
}

func (_c *MockClientInterface_GetAllCarts_Call) Run(run func(ctx context.Context, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_GetAllCarts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_GetAllCarts_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_GetAllCarts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_GetAllCarts_Call) RunAndReturn(run func(context.Context, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_GetAllCarts_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllProducts provides a mock function with given fields: ctx, reqEditors
func (_m *MockClientInterface) GetAllProducts(ctx context.Context, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAllProducts")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_GetAllProducts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllProducts'
type MockClientInterface_GetAllProducts_Call struct {
	*mock.Call
}

// GetAllProducts is a helper method to define mock.On call
//   - ctx context.Context
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) GetAllProducts(ctx interface{}, reqEditors ...interface{}) *MockClientInterface_GetAllProducts_Call {
	return &MockClientInterface_GetAllProducts_Call{Call: _e.mock.On("GetAllProducts",
		append([]interface{}{ctx}, reqEditors...)...)}
}

func (_c *MockClientInterface_GetAllProducts_Call) Run(run func(ctx context.Context, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_GetAllProducts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_GetAllProducts_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_GetAllProducts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_GetAllProducts_Call) RunAndReturn(run func(context.Context, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_GetAllProducts_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllUsers provides a mock function with given fields: ctx, reqEditors
func (_m *MockClientInterface) GetAllUsers(ctx context.Context, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAllUsers")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_GetAllUsers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllUsers'
type MockClientInterface_GetAllUsers_Call struct {
	*mock.Call
}

// GetAllUsers is a helper method to define mock.On call
//   - ctx context.Context
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) GetAllUsers(ctx interface{}, reqEditors ...interface{}) *MockClientInterface_GetAllUsers_Call {
	return &MockClientInterface_GetAllUsers_Call{Call: _e.mock.On("GetAllUsers",
		append([]interface{}{ctx}, reqEditors...)...)}
}

func (_c *MockClientInterface_GetAllUsers_Call) Run(run func(ctx context.Context, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_GetAllUsers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_GetAllUsers_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_GetAllUsers_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_GetAllUsers_Call) RunAndReturn(run func(context.Context, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_GetAllUsers_Call {
	_c.Call.Return(run)
	return _c
}

// GetCartById provides a mock function with given fields: ctx, id, reqEditors
func (_m *MockClientInterface) GetCartById(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCartById")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, id, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, id, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_GetCartById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCartById'
type MockClientInterface_GetCartById_Call struct {
	*mock.Call
}

// GetCartById is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) GetCartById(ctx interface{}, id interface{}, reqEditors ...interface{}) *MockClientInterface_GetCartById_Call {
	return &MockClientInterface_GetCartById_Call{Call: _e.mock.On("GetCartById",
		append([]interface{}{ctx, id}, reqEditors...)...)}
}

func (_c *MockClientInterface_GetCartById_Call) Run(run func(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_GetCartById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_GetCartById_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_GetCartById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_GetCartById_Call) RunAndReturn(run func(context.Context, int, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_GetCartById_Call {
	_c.Call.Return(run)
	return _c
}

// GetProductById provides a mock function with given fields: ctx, id, reqEditors
func (_m *MockClientInterface) GetProductById(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProductById")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, id, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, id, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_GetProductById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProductById'
type MockClientInterface_GetProductById_Call struct {
	*mock.Call
}

// GetProductById is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) GetProductById(ctx interface{}, id interface{}, reqEditors ...interface{}) *MockClientInterface_GetProductById_Call {
	return &MockClientInterface_GetProductById_Call{Call: _e.mock.On("GetProductById",
		append([]interface{}{ctx, id}, reqEditors...)...)}
}

func (_c *MockClientInterface_GetProductById_Call) Run(run func(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_GetProductById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_GetProductById_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_GetProductById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_GetProductById_Call) RunAndReturn(run func(context.Context, int, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_GetProductById_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserById provides a mock function with given fields: ctx, id, reqEditors
func (_m *MockClientInterface) GetUserById(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUserById")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, id, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, id, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_GetUserById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserById'
type MockClientInterface_GetUserById_Call struct {
	*mock.Call
}

// GetUserById is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) GetUserById(ctx interface{}, id interface{}, reqEditors ...interface{}) *MockClientInterface_GetUserById_Call {
	return &MockClientInterface_GetUserById_Call{Call: _e.mock.On("GetUserById",
		append([]interface{}{ctx, id}, reqEditors...)...)}
}

func (_c *MockClientInterface_GetUserById_Call) Run(run func(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_GetUserById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_GetUserById_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_GetUserById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_GetUserById_Call) RunAndReturn(run func(context.Context, int, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_GetUserById_Call {
	_c.Call.Return(run)
	return _c
}

// LoginUser provides a mock function with given fields: ctx, body, reqEditors
func (_m *MockClientInterface) LoginUser(ctx context.Context, body fakestore.Login, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoginUser")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.Login, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.Login, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, fakestore.Login, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_LoginUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoginUser'
type MockClientInterface_LoginUser_Call struct {
	*mock.Call
}

// LoginUser is a helper method to define mock.On call
//   - ctx context.Context
//   - body fakestore.Login
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) LoginUser(ctx interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_LoginUser_Call {
	return &MockClientInterface_LoginUser_Call{Call: _e.mock.On("LoginUser",
		append([]interface{}{ctx, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_LoginUser_Call) Run(run func(ctx context.Context, body fakestore.Login, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_LoginUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(fakestore.Login), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_LoginUser_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_LoginUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_LoginUser_Call) RunAndReturn(run func(context.Context, fakestore.Login, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_LoginUser_Call {
	_c.Call.Return(run)
	return _c
}

// LoginUserWithBody provides a mock function with given fields: ctx, contentType, body, reqEditors
func (_m *MockClientInterface) LoginUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoginUserWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_LoginUserWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoginUserWithBody'
type MockClientInterface_LoginUserWithBody_Call struct {
	*mock.Call
}

// LoginUserWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) LoginUserWithBody(ctx interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_LoginUserWithBody_Call {
	return &MockClientInterface_LoginUserWithBody_Call{Call: _e.mock.On("LoginUserWithBody",
		append([]interface{}{ctx, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_LoginUserWithBody_Call) Run(run func(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_LoginUserWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_LoginUserWithBody_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_LoginUserWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_LoginUserWithBody_Call) RunAndReturn(run func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_LoginUserWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCart provides a mock function with given fields: ctx, id, body, reqEditors
func (_m *MockClientInterface) UpdateCart(ctx context.Context, id int, body fakestore.Cart, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCart")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, fakestore.Cart, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, id, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, fakestore.Cart, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, id, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, fakestore.Cart, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_UpdateCart_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCart'
type MockClientInterface_UpdateCart_Call struct {
	*mock.Call
}

// UpdateCart is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - body fakestore.Cart
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) UpdateCart(ctx interface{}, id interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_UpdateCart_Call {
	return &MockClientInterface_UpdateCart_Call{Call: _e.mock.On("UpdateCart",
		append([]interface{}{ctx, id, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_UpdateCart_Call) Run(run func(ctx context.Context, id int, body fakestore.Cart, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_UpdateCart_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), args[2].(fakestore.Cart), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_UpdateCart_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_UpdateCart_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_UpdateCart_Call) RunAndReturn(run func(context.Context, int, fakestore.Cart, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_UpdateCart_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCartWithBody provides a mock function with given fields: ctx, id, contentType, body, reqEditors
func (_m *MockClientInterface) UpdateCartWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCartWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, id, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, id, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_UpdateCartWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCartWithBody'
type MockClientInterface_UpdateCartWithBody_Call struct {
	*mock.Call
}

// UpdateCartWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) UpdateCartWithBody(ctx interface{}, id interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_UpdateCartWithBody_Call {
	return &MockClientInterface_UpdateCartWithBody_Call{Call: _e.mock.On("UpdateCartWithBody",
		append([]interface{}{ctx, id, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_UpdateCartWithBody_Call) Run(run func(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_UpdateCartWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_UpdateCartWithBody_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_UpdateCartWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_UpdateCartWithBody_Call) RunAndReturn(run func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_UpdateCartWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProduct provides a mock function with given fields: ctx, id, body, reqEditors
func (_m *MockClientInterface) UpdateProduct(ctx context.Context, id int, body fakestore.Product, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProduct")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, fakestore.Product, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, id, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, fakestore.Product, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, id, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, fakestore.Product, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_UpdateProduct_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProduct'
type MockClientInterface_UpdateProduct_Call struct {
	*mock.Call
}

// UpdateProduct is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - body fakestore.Product
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) UpdateProduct(ctx interface{}, id interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_UpdateProduct_Call {
	return &MockClientInterface_UpdateProduct_Call{Call: _e.mock.On("UpdateProduct",
		append([]interface{}{ctx, id, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_UpdateProduct_Call) Run(run func(ctx context.Context, id int, body fakestore.Product, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_UpdateProduct_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), args[2].(fakestore.Product), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_UpdateProduct_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_UpdateProduct_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_UpdateProduct_Call) RunAndReturn(run func(context.Context, int, fakestore.Product, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_UpdateProduct_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProductWithBody provides a mock function with given fields: ctx, id, contentType, body, reqEditors
func (_m *MockClientInterface) UpdateProductWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProductWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, id, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, id, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_UpdateProductWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProductWithBody'
type MockClientInterface_UpdateProductWithBody_Call struct {
	*mock.Call
}

// UpdateProductWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) UpdateProductWithBody(ctx interface{}, id interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_UpdateProductWithBody_Call {
	return &MockClientInterface_UpdateProductWithBody_Call{Call: _e.mock.On("UpdateProductWithBody",
		append([]interface{}{ctx, id, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_UpdateProductWithBody_Call) Run(run func(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_UpdateProductWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_UpdateProductWithBody_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_UpdateProductWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_UpdateProductWithBody_Call) RunAndReturn(run func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_UpdateProductWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUser provides a mock function with given fields: ctx, id, body, reqEditors
func (_m *MockClientInterface) UpdateUser(ctx context.Context, id int, body fakestore.User, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUser")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, fakestore.User, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, id, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, fakestore.User, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, id, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, fakestore.User, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_UpdateUser_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUser'
type MockClientInterface_UpdateUser_Call struct {
	*mock.Call
}

// UpdateUser is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - body fakestore.User
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) UpdateUser(ctx interface{}, id interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_UpdateUser_Call {
	return &MockClientInterface_UpdateUser_Call{Call: _e.mock.On("UpdateUser",
		append([]interface{}{ctx, id, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_UpdateUser_Call) Run(run func(ctx context.Context, id int, body fakestore.User, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_UpdateUser_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), args[2].(fakestore.User), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_UpdateUser_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_UpdateUser_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_UpdateUser_Call) RunAndReturn(run func(context.Context, int, fakestore.User, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_UpdateUser_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserWithBody provides a mock function with given fields: ctx, id, contentType, body, reqEditors
func (_m *MockClientInterface) UpdateUserWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*http.Response, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserWithBody")
	}

	var r0 *http.Response
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)); ok {
		return rf(ctx, id, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) *http.Response); ok {
		r0 = rf(ctx, id, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Response)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientInterface_UpdateUserWithBody_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserWithBody'
type MockClientInterface_UpdateUserWithBody_Call struct {
	*mock.Call
}

// UpdateUserWithBody is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientInterface_Expecter) UpdateUserWithBody(ctx interface{}, id interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientInterface_UpdateUserWithBody_Call {
	return &MockClientInterface_UpdateUserWithBody_Call{Call: _e.mock.On("UpdateUserWithBody",
		append([]interface{}{ctx, id, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientInterface_UpdateUserWithBody_Call) Run(run func(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientInterface_UpdateUserWithBody_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientInterface_UpdateUserWithBody_Call) Return(_a0 *http.Response, _a1 error) *MockClientInterface_UpdateUserWithBody_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientInterface_UpdateUserWithBody_Call) RunAndReturn(run func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) (*http.Response, error)) *MockClientInterface_UpdateUserWithBody_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockClientInterface creates a new instance of MockClientInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClientInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClientInterface {
	mock := &MockClientInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
