// Code generated by mockery v2.52.4. DO NOT EDIT.

package fakestore

import (
	context "context"
	io "io"

	fakestore "github.com/radityacandra/ecommerce-connector-cli/internal/application/product/client/fakestore"

	mock "github.com/stretchr/testify/mock"
)

// MockClientWithResponsesInterface is an autogenerated mock type for the ClientWithResponsesInterface type
type MockClientWithResponsesInterface struct {
	mock.Mock
}

type MockClientWithResponsesInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MockClientWithResponsesInterface) EXPECT() *MockClientWithResponsesInterface_Expecter {
	return &MockClientWithResponsesInterface_Expecter{mock: &_m.Mock}
}

// AddCartWithBodyWithResponse provides a mock function with given fields: ctx, contentType, body, reqEditors
func (_m *MockClientWithResponsesInterface) AddCartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*fakestore.AddCartResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddCartWithBodyWithResponse")
	}

	var r0 *fakestore.AddCartResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.AddCartResponse, error)); ok {
		return rf(ctx, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) *fakestore.AddCartResponse); ok {
		r0 = rf(ctx, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.AddCartResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_AddCartWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCartWithBodyWithResponse'
type MockClientWithResponsesInterface_AddCartWithBodyWithResponse_Call struct {
	*mock.Call
}

// AddCartWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) AddCartWithBodyWithResponse(ctx interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_AddCartWithBodyWithResponse_Call {
	return &MockClientWithResponsesInterface_AddCartWithBodyWithResponse_Call{Call: _e.mock.On("AddCartWithBodyWithResponse",
		append([]interface{}{ctx, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_AddCartWithBodyWithResponse_Call) Run(run func(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_AddCartWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_AddCartWithBodyWithResponse_Call) Return(_a0 *fakestore.AddCartResponse, _a1 error) *MockClientWithResponsesInterface_AddCartWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_AddCartWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.AddCartResponse, error)) *MockClientWithResponsesInterface_AddCartWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddCartWithResponse provides a mock function with given fields: ctx, body, reqEditors
func (_m *MockClientWithResponsesInterface) AddCartWithResponse(ctx context.Context, body fakestore.Cart, reqEditors ...fakestore.RequestEditorFn) (*fakestore.AddCartResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddCartWithResponse")
	}

	var r0 *fakestore.AddCartResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.Cart, ...fakestore.RequestEditorFn) (*fakestore.AddCartResponse, error)); ok {
		return rf(ctx, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.Cart, ...fakestore.RequestEditorFn) *fakestore.AddCartResponse); ok {
		r0 = rf(ctx, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.AddCartResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, fakestore.Cart, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_AddCartWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddCartWithResponse'
type MockClientWithResponsesInterface_AddCartWithResponse_Call struct {
	*mock.Call
}

// AddCartWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - body fakestore.Cart
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) AddCartWithResponse(ctx interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_AddCartWithResponse_Call {
	return &MockClientWithResponsesInterface_AddCartWithResponse_Call{Call: _e.mock.On("AddCartWithResponse",
		append([]interface{}{ctx, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_AddCartWithResponse_Call) Run(run func(ctx context.Context, body fakestore.Cart, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_AddCartWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(fakestore.Cart), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_AddCartWithResponse_Call) Return(_a0 *fakestore.AddCartResponse, _a1 error) *MockClientWithResponsesInterface_AddCartWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_AddCartWithResponse_Call) RunAndReturn(run func(context.Context, fakestore.Cart, ...fakestore.RequestEditorFn) (*fakestore.AddCartResponse, error)) *MockClientWithResponsesInterface_AddCartWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddProductWithBodyWithResponse provides a mock function with given fields: ctx, contentType, body, reqEditors
func (_m *MockClientWithResponsesInterface) AddProductWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*fakestore.AddProductResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddProductWithBodyWithResponse")
	}

	var r0 *fakestore.AddProductResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.AddProductResponse, error)); ok {
		return rf(ctx, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) *fakestore.AddProductResponse); ok {
		r0 = rf(ctx, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.AddProductResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_AddProductWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddProductWithBodyWithResponse'
type MockClientWithResponsesInterface_AddProductWithBodyWithResponse_Call struct {
	*mock.Call
}

// AddProductWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) AddProductWithBodyWithResponse(ctx interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_AddProductWithBodyWithResponse_Call {
	return &MockClientWithResponsesInterface_AddProductWithBodyWithResponse_Call{Call: _e.mock.On("AddProductWithBodyWithResponse",
		append([]interface{}{ctx, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_AddProductWithBodyWithResponse_Call) Run(run func(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_AddProductWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_AddProductWithBodyWithResponse_Call) Return(_a0 *fakestore.AddProductResponse, _a1 error) *MockClientWithResponsesInterface_AddProductWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_AddProductWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.AddProductResponse, error)) *MockClientWithResponsesInterface_AddProductWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddProductWithResponse provides a mock function with given fields: ctx, body, reqEditors
func (_m *MockClientWithResponsesInterface) AddProductWithResponse(ctx context.Context, body fakestore.Product, reqEditors ...fakestore.RequestEditorFn) (*fakestore.AddProductResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddProductWithResponse")
	}

	var r0 *fakestore.AddProductResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.Product, ...fakestore.RequestEditorFn) (*fakestore.AddProductResponse, error)); ok {
		return rf(ctx, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.Product, ...fakestore.RequestEditorFn) *fakestore.AddProductResponse); ok {
		r0 = rf(ctx, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.AddProductResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, fakestore.Product, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_AddProductWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddProductWithResponse'
type MockClientWithResponsesInterface_AddProductWithResponse_Call struct {
	*mock.Call
}

// AddProductWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - body fakestore.Product
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) AddProductWithResponse(ctx interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_AddProductWithResponse_Call {
	return &MockClientWithResponsesInterface_AddProductWithResponse_Call{Call: _e.mock.On("AddProductWithResponse",
		append([]interface{}{ctx, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_AddProductWithResponse_Call) Run(run func(ctx context.Context, body fakestore.Product, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_AddProductWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(fakestore.Product), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_AddProductWithResponse_Call) Return(_a0 *fakestore.AddProductResponse, _a1 error) *MockClientWithResponsesInterface_AddProductWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_AddProductWithResponse_Call) RunAndReturn(run func(context.Context, fakestore.Product, ...fakestore.RequestEditorFn) (*fakestore.AddProductResponse, error)) *MockClientWithResponsesInterface_AddProductWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddUserWithBodyWithResponse provides a mock function with given fields: ctx, contentType, body, reqEditors
func (_m *MockClientWithResponsesInterface) AddUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*fakestore.AddUserResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddUserWithBodyWithResponse")
	}

	var r0 *fakestore.AddUserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.AddUserResponse, error)); ok {
		return rf(ctx, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) *fakestore.AddUserResponse); ok {
		r0 = rf(ctx, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.AddUserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_AddUserWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddUserWithBodyWithResponse'
type MockClientWithResponsesInterface_AddUserWithBodyWithResponse_Call struct {
	*mock.Call
}

// AddUserWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) AddUserWithBodyWithResponse(ctx interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_AddUserWithBodyWithResponse_Call {
	return &MockClientWithResponsesInterface_AddUserWithBodyWithResponse_Call{Call: _e.mock.On("AddUserWithBodyWithResponse",
		append([]interface{}{ctx, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_AddUserWithBodyWithResponse_Call) Run(run func(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_AddUserWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_AddUserWithBodyWithResponse_Call) Return(_a0 *fakestore.AddUserResponse, _a1 error) *MockClientWithResponsesInterface_AddUserWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_AddUserWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.AddUserResponse, error)) *MockClientWithResponsesInterface_AddUserWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// AddUserWithResponse provides a mock function with given fields: ctx, body, reqEditors
func (_m *MockClientWithResponsesInterface) AddUserWithResponse(ctx context.Context, body fakestore.User, reqEditors ...fakestore.RequestEditorFn) (*fakestore.AddUserResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for AddUserWithResponse")
	}

	var r0 *fakestore.AddUserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.User, ...fakestore.RequestEditorFn) (*fakestore.AddUserResponse, error)); ok {
		return rf(ctx, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.User, ...fakestore.RequestEditorFn) *fakestore.AddUserResponse); ok {
		r0 = rf(ctx, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.AddUserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, fakestore.User, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_AddUserWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddUserWithResponse'
type MockClientWithResponsesInterface_AddUserWithResponse_Call struct {
	*mock.Call
}

// AddUserWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - body fakestore.User
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) AddUserWithResponse(ctx interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_AddUserWithResponse_Call {
	return &MockClientWithResponsesInterface_AddUserWithResponse_Call{Call: _e.mock.On("AddUserWithResponse",
		append([]interface{}{ctx, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_AddUserWithResponse_Call) Run(run func(ctx context.Context, body fakestore.User, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_AddUserWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(fakestore.User), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_AddUserWithResponse_Call) Return(_a0 *fakestore.AddUserResponse, _a1 error) *MockClientWithResponsesInterface_AddUserWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_AddUserWithResponse_Call) RunAndReturn(run func(context.Context, fakestore.User, ...fakestore.RequestEditorFn) (*fakestore.AddUserResponse, error)) *MockClientWithResponsesInterface_AddUserWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteCartWithResponse provides a mock function with given fields: ctx, id, reqEditors
func (_m *MockClientWithResponsesInterface) DeleteCartWithResponse(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn) (*fakestore.DeleteCartResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteCartWithResponse")
	}

	var r0 *fakestore.DeleteCartResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) (*fakestore.DeleteCartResponse, error)); ok {
		return rf(ctx, id, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) *fakestore.DeleteCartResponse); ok {
		r0 = rf(ctx, id, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.DeleteCartResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_DeleteCartWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteCartWithResponse'
type MockClientWithResponsesInterface_DeleteCartWithResponse_Call struct {
	*mock.Call
}

// DeleteCartWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) DeleteCartWithResponse(ctx interface{}, id interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_DeleteCartWithResponse_Call {
	return &MockClientWithResponsesInterface_DeleteCartWithResponse_Call{Call: _e.mock.On("DeleteCartWithResponse",
		append([]interface{}{ctx, id}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_DeleteCartWithResponse_Call) Run(run func(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_DeleteCartWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_DeleteCartWithResponse_Call) Return(_a0 *fakestore.DeleteCartResponse, _a1 error) *MockClientWithResponsesInterface_DeleteCartWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_DeleteCartWithResponse_Call) RunAndReturn(run func(context.Context, int, ...fakestore.RequestEditorFn) (*fakestore.DeleteCartResponse, error)) *MockClientWithResponsesInterface_DeleteCartWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteProductWithResponse provides a mock function with given fields: ctx, id, reqEditors
func (_m *MockClientWithResponsesInterface) DeleteProductWithResponse(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn) (*fakestore.DeleteProductResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteProductWithResponse")
	}

	var r0 *fakestore.DeleteProductResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) (*fakestore.DeleteProductResponse, error)); ok {
		return rf(ctx, id, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) *fakestore.DeleteProductResponse); ok {
		r0 = rf(ctx, id, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.DeleteProductResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_DeleteProductWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteProductWithResponse'
type MockClientWithResponsesInterface_DeleteProductWithResponse_Call struct {
	*mock.Call
}

// DeleteProductWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) DeleteProductWithResponse(ctx interface{}, id interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_DeleteProductWithResponse_Call {
	return &MockClientWithResponsesInterface_DeleteProductWithResponse_Call{Call: _e.mock.On("DeleteProductWithResponse",
		append([]interface{}{ctx, id}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_DeleteProductWithResponse_Call) Run(run func(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_DeleteProductWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_DeleteProductWithResponse_Call) Return(_a0 *fakestore.DeleteProductResponse, _a1 error) *MockClientWithResponsesInterface_DeleteProductWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_DeleteProductWithResponse_Call) RunAndReturn(run func(context.Context, int, ...fakestore.RequestEditorFn) (*fakestore.DeleteProductResponse, error)) *MockClientWithResponsesInterface_DeleteProductWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteUserWithResponse provides a mock function with given fields: ctx, id, reqEditors
func (_m *MockClientWithResponsesInterface) DeleteUserWithResponse(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn) (*fakestore.DeleteUserResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for DeleteUserWithResponse")
	}

	var r0 *fakestore.DeleteUserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) (*fakestore.DeleteUserResponse, error)); ok {
		return rf(ctx, id, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) *fakestore.DeleteUserResponse); ok {
		r0 = rf(ctx, id, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.DeleteUserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_DeleteUserWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteUserWithResponse'
type MockClientWithResponsesInterface_DeleteUserWithResponse_Call struct {
	*mock.Call
}

// DeleteUserWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) DeleteUserWithResponse(ctx interface{}, id interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_DeleteUserWithResponse_Call {
	return &MockClientWithResponsesInterface_DeleteUserWithResponse_Call{Call: _e.mock.On("DeleteUserWithResponse",
		append([]interface{}{ctx, id}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_DeleteUserWithResponse_Call) Run(run func(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_DeleteUserWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_DeleteUserWithResponse_Call) Return(_a0 *fakestore.DeleteUserResponse, _a1 error) *MockClientWithResponsesInterface_DeleteUserWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_DeleteUserWithResponse_Call) RunAndReturn(run func(context.Context, int, ...fakestore.RequestEditorFn) (*fakestore.DeleteUserResponse, error)) *MockClientWithResponsesInterface_DeleteUserWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllCartsWithResponse provides a mock function with given fields: ctx, reqEditors
func (_m *MockClientWithResponsesInterface) GetAllCartsWithResponse(ctx context.Context, reqEditors ...fakestore.RequestEditorFn) (*fakestore.GetAllCartsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAllCartsWithResponse")
	}

	var r0 *fakestore.GetAllCartsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...fakestore.RequestEditorFn) (*fakestore.GetAllCartsResponse, error)); ok {
		return rf(ctx, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...fakestore.RequestEditorFn) *fakestore.GetAllCartsResponse); ok {
		r0 = rf(ctx, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.GetAllCartsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_GetAllCartsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllCartsWithResponse'
type MockClientWithResponsesInterface_GetAllCartsWithResponse_Call struct {
	*mock.Call
}

// GetAllCartsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) GetAllCartsWithResponse(ctx interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_GetAllCartsWithResponse_Call {
	return &MockClientWithResponsesInterface_GetAllCartsWithResponse_Call{Call: _e.mock.On("GetAllCartsWithResponse",
		append([]interface{}{ctx}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_GetAllCartsWithResponse_Call) Run(run func(ctx context.Context, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_GetAllCartsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_GetAllCartsWithResponse_Call) Return(_a0 *fakestore.GetAllCartsResponse, _a1 error) *MockClientWithResponsesInterface_GetAllCartsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_GetAllCartsWithResponse_Call) RunAndReturn(run func(context.Context, ...fakestore.RequestEditorFn) (*fakestore.GetAllCartsResponse, error)) *MockClientWithResponsesInterface_GetAllCartsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllProductsWithResponse provides a mock function with given fields: ctx, reqEditors
func (_m *MockClientWithResponsesInterface) GetAllProductsWithResponse(ctx context.Context, reqEditors ...fakestore.RequestEditorFn) (*fakestore.GetAllProductsResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAllProductsWithResponse")
	}

	var r0 *fakestore.GetAllProductsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...fakestore.RequestEditorFn) (*fakestore.GetAllProductsResponse, error)); ok {
		return rf(ctx, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...fakestore.RequestEditorFn) *fakestore.GetAllProductsResponse); ok {
		r0 = rf(ctx, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.GetAllProductsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_GetAllProductsWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllProductsWithResponse'
type MockClientWithResponsesInterface_GetAllProductsWithResponse_Call struct {
	*mock.Call
}

// GetAllProductsWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) GetAllProductsWithResponse(ctx interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_GetAllProductsWithResponse_Call {
	return &MockClientWithResponsesInterface_GetAllProductsWithResponse_Call{Call: _e.mock.On("GetAllProductsWithResponse",
		append([]interface{}{ctx}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_GetAllProductsWithResponse_Call) Run(run func(ctx context.Context, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_GetAllProductsWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_GetAllProductsWithResponse_Call) Return(_a0 *fakestore.GetAllProductsResponse, _a1 error) *MockClientWithResponsesInterface_GetAllProductsWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_GetAllProductsWithResponse_Call) RunAndReturn(run func(context.Context, ...fakestore.RequestEditorFn) (*fakestore.GetAllProductsResponse, error)) *MockClientWithResponsesInterface_GetAllProductsWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllUsersWithResponse provides a mock function with given fields: ctx, reqEditors
func (_m *MockClientWithResponsesInterface) GetAllUsersWithResponse(ctx context.Context, reqEditors ...fakestore.RequestEditorFn) (*fakestore.GetAllUsersResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAllUsersWithResponse")
	}

	var r0 *fakestore.GetAllUsersResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...fakestore.RequestEditorFn) (*fakestore.GetAllUsersResponse, error)); ok {
		return rf(ctx, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...fakestore.RequestEditorFn) *fakestore.GetAllUsersResponse); ok {
		r0 = rf(ctx, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.GetAllUsersResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_GetAllUsersWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllUsersWithResponse'
type MockClientWithResponsesInterface_GetAllUsersWithResponse_Call struct {
	*mock.Call
}

// GetAllUsersWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) GetAllUsersWithResponse(ctx interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_GetAllUsersWithResponse_Call {
	return &MockClientWithResponsesInterface_GetAllUsersWithResponse_Call{Call: _e.mock.On("GetAllUsersWithResponse",
		append([]interface{}{ctx}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_GetAllUsersWithResponse_Call) Run(run func(ctx context.Context, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_GetAllUsersWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-1)
		for i, a := range args[1:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_GetAllUsersWithResponse_Call) Return(_a0 *fakestore.GetAllUsersResponse, _a1 error) *MockClientWithResponsesInterface_GetAllUsersWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_GetAllUsersWithResponse_Call) RunAndReturn(run func(context.Context, ...fakestore.RequestEditorFn) (*fakestore.GetAllUsersResponse, error)) *MockClientWithResponsesInterface_GetAllUsersWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetCartByIdWithResponse provides a mock function with given fields: ctx, id, reqEditors
func (_m *MockClientWithResponsesInterface) GetCartByIdWithResponse(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn) (*fakestore.GetCartByIdResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetCartByIdWithResponse")
	}

	var r0 *fakestore.GetCartByIdResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) (*fakestore.GetCartByIdResponse, error)); ok {
		return rf(ctx, id, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) *fakestore.GetCartByIdResponse); ok {
		r0 = rf(ctx, id, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.GetCartByIdResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_GetCartByIdWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCartByIdWithResponse'
type MockClientWithResponsesInterface_GetCartByIdWithResponse_Call struct {
	*mock.Call
}

// GetCartByIdWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) GetCartByIdWithResponse(ctx interface{}, id interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_GetCartByIdWithResponse_Call {
	return &MockClientWithResponsesInterface_GetCartByIdWithResponse_Call{Call: _e.mock.On("GetCartByIdWithResponse",
		append([]interface{}{ctx, id}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_GetCartByIdWithResponse_Call) Run(run func(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_GetCartByIdWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_GetCartByIdWithResponse_Call) Return(_a0 *fakestore.GetCartByIdResponse, _a1 error) *MockClientWithResponsesInterface_GetCartByIdWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_GetCartByIdWithResponse_Call) RunAndReturn(run func(context.Context, int, ...fakestore.RequestEditorFn) (*fakestore.GetCartByIdResponse, error)) *MockClientWithResponsesInterface_GetCartByIdWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetProductByIdWithResponse provides a mock function with given fields: ctx, id, reqEditors
func (_m *MockClientWithResponsesInterface) GetProductByIdWithResponse(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn) (*fakestore.GetProductByIdResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetProductByIdWithResponse")
	}

	var r0 *fakestore.GetProductByIdResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) (*fakestore.GetProductByIdResponse, error)); ok {
		return rf(ctx, id, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) *fakestore.GetProductByIdResponse); ok {
		r0 = rf(ctx, id, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.GetProductByIdResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_GetProductByIdWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetProductByIdWithResponse'
type MockClientWithResponsesInterface_GetProductByIdWithResponse_Call struct {
	*mock.Call
}

// GetProductByIdWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) GetProductByIdWithResponse(ctx interface{}, id interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_GetProductByIdWithResponse_Call {
	return &MockClientWithResponsesInterface_GetProductByIdWithResponse_Call{Call: _e.mock.On("GetProductByIdWithResponse",
		append([]interface{}{ctx, id}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_GetProductByIdWithResponse_Call) Run(run func(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_GetProductByIdWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_GetProductByIdWithResponse_Call) Return(_a0 *fakestore.GetProductByIdResponse, _a1 error) *MockClientWithResponsesInterface_GetProductByIdWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_GetProductByIdWithResponse_Call) RunAndReturn(run func(context.Context, int, ...fakestore.RequestEditorFn) (*fakestore.GetProductByIdResponse, error)) *MockClientWithResponsesInterface_GetProductByIdWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserByIdWithResponse provides a mock function with given fields: ctx, id, reqEditors
func (_m *MockClientWithResponsesInterface) GetUserByIdWithResponse(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn) (*fakestore.GetUserByIdResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetUserByIdWithResponse")
	}

	var r0 *fakestore.GetUserByIdResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) (*fakestore.GetUserByIdResponse, error)); ok {
		return rf(ctx, id, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, ...fakestore.RequestEditorFn) *fakestore.GetUserByIdResponse); ok {
		r0 = rf(ctx, id, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.GetUserByIdResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_GetUserByIdWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserByIdWithResponse'
type MockClientWithResponsesInterface_GetUserByIdWithResponse_Call struct {
	*mock.Call
}

// GetUserByIdWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) GetUserByIdWithResponse(ctx interface{}, id interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_GetUserByIdWithResponse_Call {
	return &MockClientWithResponsesInterface_GetUserByIdWithResponse_Call{Call: _e.mock.On("GetUserByIdWithResponse",
		append([]interface{}{ctx, id}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_GetUserByIdWithResponse_Call) Run(run func(ctx context.Context, id int, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_GetUserByIdWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_GetUserByIdWithResponse_Call) Return(_a0 *fakestore.GetUserByIdResponse, _a1 error) *MockClientWithResponsesInterface_GetUserByIdWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_GetUserByIdWithResponse_Call) RunAndReturn(run func(context.Context, int, ...fakestore.RequestEditorFn) (*fakestore.GetUserByIdResponse, error)) *MockClientWithResponsesInterface_GetUserByIdWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// LoginUserWithBodyWithResponse provides a mock function with given fields: ctx, contentType, body, reqEditors
func (_m *MockClientWithResponsesInterface) LoginUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*fakestore.LoginUserResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoginUserWithBodyWithResponse")
	}

	var r0 *fakestore.LoginUserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.LoginUserResponse, error)); ok {
		return rf(ctx, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) *fakestore.LoginUserResponse); ok {
		r0 = rf(ctx, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.LoginUserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_LoginUserWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoginUserWithBodyWithResponse'
type MockClientWithResponsesInterface_LoginUserWithBodyWithResponse_Call struct {
	*mock.Call
}

// LoginUserWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) LoginUserWithBodyWithResponse(ctx interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_LoginUserWithBodyWithResponse_Call {
	return &MockClientWithResponsesInterface_LoginUserWithBodyWithResponse_Call{Call: _e.mock.On("LoginUserWithBodyWithResponse",
		append([]interface{}{ctx, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_LoginUserWithBodyWithResponse_Call) Run(run func(ctx context.Context, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_LoginUserWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(string), args[2].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_LoginUserWithBodyWithResponse_Call) Return(_a0 *fakestore.LoginUserResponse, _a1 error) *MockClientWithResponsesInterface_LoginUserWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_LoginUserWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.LoginUserResponse, error)) *MockClientWithResponsesInterface_LoginUserWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// LoginUserWithResponse provides a mock function with given fields: ctx, body, reqEditors
func (_m *MockClientWithResponsesInterface) LoginUserWithResponse(ctx context.Context, body fakestore.Login, reqEditors ...fakestore.RequestEditorFn) (*fakestore.LoginUserResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for LoginUserWithResponse")
	}

	var r0 *fakestore.LoginUserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.Login, ...fakestore.RequestEditorFn) (*fakestore.LoginUserResponse, error)); ok {
		return rf(ctx, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, fakestore.Login, ...fakestore.RequestEditorFn) *fakestore.LoginUserResponse); ok {
		r0 = rf(ctx, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.LoginUserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, fakestore.Login, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_LoginUserWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LoginUserWithResponse'
type MockClientWithResponsesInterface_LoginUserWithResponse_Call struct {
	*mock.Call
}

// LoginUserWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - body fakestore.Login
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) LoginUserWithResponse(ctx interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_LoginUserWithResponse_Call {
	return &MockClientWithResponsesInterface_LoginUserWithResponse_Call{Call: _e.mock.On("LoginUserWithResponse",
		append([]interface{}{ctx, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_LoginUserWithResponse_Call) Run(run func(ctx context.Context, body fakestore.Login, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_LoginUserWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(fakestore.Login), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_LoginUserWithResponse_Call) Return(_a0 *fakestore.LoginUserResponse, _a1 error) *MockClientWithResponsesInterface_LoginUserWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_LoginUserWithResponse_Call) RunAndReturn(run func(context.Context, fakestore.Login, ...fakestore.RequestEditorFn) (*fakestore.LoginUserResponse, error)) *MockClientWithResponsesInterface_LoginUserWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCartWithBodyWithResponse provides a mock function with given fields: ctx, id, contentType, body, reqEditors
func (_m *MockClientWithResponsesInterface) UpdateCartWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*fakestore.UpdateCartResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCartWithBodyWithResponse")
	}

	var r0 *fakestore.UpdateCartResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.UpdateCartResponse, error)); ok {
		return rf(ctx, id, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) *fakestore.UpdateCartResponse); ok {
		r0 = rf(ctx, id, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.UpdateCartResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_UpdateCartWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCartWithBodyWithResponse'
type MockClientWithResponsesInterface_UpdateCartWithBodyWithResponse_Call struct {
	*mock.Call
}

// UpdateCartWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) UpdateCartWithBodyWithResponse(ctx interface{}, id interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_UpdateCartWithBodyWithResponse_Call {
	return &MockClientWithResponsesInterface_UpdateCartWithBodyWithResponse_Call{Call: _e.mock.On("UpdateCartWithBodyWithResponse",
		append([]interface{}{ctx, id, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_UpdateCartWithBodyWithResponse_Call) Run(run func(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_UpdateCartWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_UpdateCartWithBodyWithResponse_Call) Return(_a0 *fakestore.UpdateCartResponse, _a1 error) *MockClientWithResponsesInterface_UpdateCartWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_UpdateCartWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.UpdateCartResponse, error)) *MockClientWithResponsesInterface_UpdateCartWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateCartWithResponse provides a mock function with given fields: ctx, id, body, reqEditors
func (_m *MockClientWithResponsesInterface) UpdateCartWithResponse(ctx context.Context, id int, body fakestore.Cart, reqEditors ...fakestore.RequestEditorFn) (*fakestore.UpdateCartResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateCartWithResponse")
	}

	var r0 *fakestore.UpdateCartResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, fakestore.Cart, ...fakestore.RequestEditorFn) (*fakestore.UpdateCartResponse, error)); ok {
		return rf(ctx, id, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, fakestore.Cart, ...fakestore.RequestEditorFn) *fakestore.UpdateCartResponse); ok {
		r0 = rf(ctx, id, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.UpdateCartResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, fakestore.Cart, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_UpdateCartWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateCartWithResponse'
type MockClientWithResponsesInterface_UpdateCartWithResponse_Call struct {
	*mock.Call
}

// UpdateCartWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - body fakestore.Cart
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) UpdateCartWithResponse(ctx interface{}, id interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_UpdateCartWithResponse_Call {
	return &MockClientWithResponsesInterface_UpdateCartWithResponse_Call{Call: _e.mock.On("UpdateCartWithResponse",
		append([]interface{}{ctx, id, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_UpdateCartWithResponse_Call) Run(run func(ctx context.Context, id int, body fakestore.Cart, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_UpdateCartWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), args[2].(fakestore.Cart), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_UpdateCartWithResponse_Call) Return(_a0 *fakestore.UpdateCartResponse, _a1 error) *MockClientWithResponsesInterface_UpdateCartWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_UpdateCartWithResponse_Call) RunAndReturn(run func(context.Context, int, fakestore.Cart, ...fakestore.RequestEditorFn) (*fakestore.UpdateCartResponse, error)) *MockClientWithResponsesInterface_UpdateCartWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProductWithBodyWithResponse provides a mock function with given fields: ctx, id, contentType, body, reqEditors
func (_m *MockClientWithResponsesInterface) UpdateProductWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*fakestore.UpdateProductResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProductWithBodyWithResponse")
	}

	var r0 *fakestore.UpdateProductResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.UpdateProductResponse, error)); ok {
		return rf(ctx, id, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) *fakestore.UpdateProductResponse); ok {
		r0 = rf(ctx, id, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.UpdateProductResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_UpdateProductWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProductWithBodyWithResponse'
type MockClientWithResponsesInterface_UpdateProductWithBodyWithResponse_Call struct {
	*mock.Call
}

// UpdateProductWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) UpdateProductWithBodyWithResponse(ctx interface{}, id interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_UpdateProductWithBodyWithResponse_Call {
	return &MockClientWithResponsesInterface_UpdateProductWithBodyWithResponse_Call{Call: _e.mock.On("UpdateProductWithBodyWithResponse",
		append([]interface{}{ctx, id, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_UpdateProductWithBodyWithResponse_Call) Run(run func(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_UpdateProductWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_UpdateProductWithBodyWithResponse_Call) Return(_a0 *fakestore.UpdateProductResponse, _a1 error) *MockClientWithResponsesInterface_UpdateProductWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_UpdateProductWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.UpdateProductResponse, error)) *MockClientWithResponsesInterface_UpdateProductWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateProductWithResponse provides a mock function with given fields: ctx, id, body, reqEditors
func (_m *MockClientWithResponsesInterface) UpdateProductWithResponse(ctx context.Context, id int, body fakestore.Product, reqEditors ...fakestore.RequestEditorFn) (*fakestore.UpdateProductResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateProductWithResponse")
	}

	var r0 *fakestore.UpdateProductResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, fakestore.Product, ...fakestore.RequestEditorFn) (*fakestore.UpdateProductResponse, error)); ok {
		return rf(ctx, id, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, fakestore.Product, ...fakestore.RequestEditorFn) *fakestore.UpdateProductResponse); ok {
		r0 = rf(ctx, id, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.UpdateProductResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, fakestore.Product, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_UpdateProductWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateProductWithResponse'
type MockClientWithResponsesInterface_UpdateProductWithResponse_Call struct {
	*mock.Call
}

// UpdateProductWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - body fakestore.Product
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) UpdateProductWithResponse(ctx interface{}, id interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_UpdateProductWithResponse_Call {
	return &MockClientWithResponsesInterface_UpdateProductWithResponse_Call{Call: _e.mock.On("UpdateProductWithResponse",
		append([]interface{}{ctx, id, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_UpdateProductWithResponse_Call) Run(run func(ctx context.Context, id int, body fakestore.Product, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_UpdateProductWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), args[2].(fakestore.Product), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_UpdateProductWithResponse_Call) Return(_a0 *fakestore.UpdateProductResponse, _a1 error) *MockClientWithResponsesInterface_UpdateProductWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_UpdateProductWithResponse_Call) RunAndReturn(run func(context.Context, int, fakestore.Product, ...fakestore.RequestEditorFn) (*fakestore.UpdateProductResponse, error)) *MockClientWithResponsesInterface_UpdateProductWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserWithBodyWithResponse provides a mock function with given fields: ctx, id, contentType, body, reqEditors
func (_m *MockClientWithResponsesInterface) UpdateUserWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn) (*fakestore.UpdateUserResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, contentType, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserWithBodyWithResponse")
	}

	var r0 *fakestore.UpdateUserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.UpdateUserResponse, error)); ok {
		return rf(ctx, id, contentType, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) *fakestore.UpdateUserResponse); ok {
		r0 = rf(ctx, id, contentType, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.UpdateUserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, contentType, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_UpdateUserWithBodyWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserWithBodyWithResponse'
type MockClientWithResponsesInterface_UpdateUserWithBodyWithResponse_Call struct {
	*mock.Call
}

// UpdateUserWithBodyWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - contentType string
//   - body io.Reader
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) UpdateUserWithBodyWithResponse(ctx interface{}, id interface{}, contentType interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_UpdateUserWithBodyWithResponse_Call {
	return &MockClientWithResponsesInterface_UpdateUserWithBodyWithResponse_Call{Call: _e.mock.On("UpdateUserWithBodyWithResponse",
		append([]interface{}{ctx, id, contentType, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_UpdateUserWithBodyWithResponse_Call) Run(run func(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_UpdateUserWithBodyWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-4)
		for i, a := range args[4:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), args[2].(string), args[3].(io.Reader), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_UpdateUserWithBodyWithResponse_Call) Return(_a0 *fakestore.UpdateUserResponse, _a1 error) *MockClientWithResponsesInterface_UpdateUserWithBodyWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_UpdateUserWithBodyWithResponse_Call) RunAndReturn(run func(context.Context, int, string, io.Reader, ...fakestore.RequestEditorFn) (*fakestore.UpdateUserResponse, error)) *MockClientWithResponsesInterface_UpdateUserWithBodyWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateUserWithResponse provides a mock function with given fields: ctx, id, body, reqEditors
func (_m *MockClientWithResponsesInterface) UpdateUserWithResponse(ctx context.Context, id int, body fakestore.User, reqEditors ...fakestore.RequestEditorFn) (*fakestore.UpdateUserResponse, error) {
	_va := make([]interface{}, len(reqEditors))
	for _i := range reqEditors {
		_va[_i] = reqEditors[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, id, body)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateUserWithResponse")
	}

	var r0 *fakestore.UpdateUserResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, fakestore.User, ...fakestore.RequestEditorFn) (*fakestore.UpdateUserResponse, error)); ok {
		return rf(ctx, id, body, reqEditors...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, fakestore.User, ...fakestore.RequestEditorFn) *fakestore.UpdateUserResponse); ok {
		r0 = rf(ctx, id, body, reqEditors...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*fakestore.UpdateUserResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, fakestore.User, ...fakestore.RequestEditorFn) error); ok {
		r1 = rf(ctx, id, body, reqEditors...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClientWithResponsesInterface_UpdateUserWithResponse_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateUserWithResponse'
type MockClientWithResponsesInterface_UpdateUserWithResponse_Call struct {
	*mock.Call
}

// UpdateUserWithResponse is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
//   - body fakestore.User
//   - reqEditors ...fakestore.RequestEditorFn
func (_e *MockClientWithResponsesInterface_Expecter) UpdateUserWithResponse(ctx interface{}, id interface{}, body interface{}, reqEditors ...interface{}) *MockClientWithResponsesInterface_UpdateUserWithResponse_Call {
	return &MockClientWithResponsesInterface_UpdateUserWithResponse_Call{Call: _e.mock.On("UpdateUserWithResponse",
		append([]interface{}{ctx, id, body}, reqEditors...)...)}
}

func (_c *MockClientWithResponsesInterface_UpdateUserWithResponse_Call) Run(run func(ctx context.Context, id int, body fakestore.User, reqEditors ...fakestore.RequestEditorFn)) *MockClientWithResponsesInterface_UpdateUserWithResponse_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]fakestore.RequestEditorFn, len(args)-3)
		for i, a := range args[3:] {
			if a != nil {
				variadicArgs[i] = a.(fakestore.RequestEditorFn)
			}
		}
		run(args[0].(context.Context), args[1].(int), args[2].(fakestore.User), variadicArgs...)
	})
	return _c
}

func (_c *MockClientWithResponsesInterface_UpdateUserWithResponse_Call) Return(_a0 *fakestore.UpdateUserResponse, _a1 error) *MockClientWithResponsesInterface_UpdateUserWithResponse_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClientWithResponsesInterface_UpdateUserWithResponse_Call) RunAndReturn(run func(context.Context, int, fakestore.User, ...fakestore.RequestEditorFn) (*fakestore.UpdateUserResponse, error)) *MockClientWithResponsesInterface_UpdateUserWithResponse_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockClientWithResponsesInterface creates a new instance of MockClientWithResponsesInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClientWithResponsesInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClientWithResponsesInterface {
	mock := &MockClientWithResponsesInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
